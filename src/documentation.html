<head>
<link rel="SHORTCUT ICON" href="favicon.ico">
<link rel="stylesheet" type="text/css" href="resources/style.css">
<title>Numeric Javascript: Documentation</title>
</head>
<body>
<a href="https://github.com/sloisel/numeric"><img style="position: absolute; top: 0; right: 0; border: 0;" src="resources/forkme.png" alt="Fork me on GitHub"></a>
<table class="nav"><tr class="nav">
<td class="nav" style="width:150px;"><img src="resources/paperplane-small.png">
<td class="navmain">
<b>Numeric Javascript: Documentation</b>
<ul class="nav">
  <li class="nav"><a id = "linkhome" class="nav" href="index.html">HOME</a></li>
  <li class="nav"><a id = "linkworkshop" class="nav" href="workshop.php">WORKSHOP</a></li>
  <li class="nav"><a id = "linkbenchmarks" class="nav" href="benchmark.html">BENCHMARKS</a></li>
  <li class="nav"><a id = "linkdoc" class="nav" href="documentation.html">DOCUMENTATION</a></li>
</ul>
<ul class="nav">
  <li class="sep">DOWNLOADS:</li>
  <li class="nav"><a id = "linklib" class="dl" href="lib/numeric.js">numeric.js</a></li>
  <li class="nav"><a id = "linklibmin" class="dl" href="lib/numeric-min.js">numeric-min.js</a></li>
</ul>
</table>
<!--
This allows regression tests to run predictably:
<pre>
> numeric.seedrandom.seedrandom('1'); Math.random = numeric.seedrandom.random; Math.random();
0.2694
</pre>
-->
<h1>Numerical analysis in Javascript</h1>

<a href="http://www.numericjs.com/">Numeric Javascript</a> is
library that provides many useful functions for numerical
calculations, particularly for linear algebra (vectors and matrices).
You can create vectors and matrices and multiply them:
<pre>
> A = [[1,2,3],[4,5,6]];
[[1,2,3],
 [4,5,6]]
> x = [7,8,9]
[7,8,9]
> numeric.dot(A,x);
[50,122]
</pre>
The example shown above can be executed in the
<a href="http://www.numericjs.com/workshop.php">Javascript Workshop</a> or at any
Javascript prompt. The Workshop provides plotting capabilities:<br>
<img src="resources/workshop.png"><br>
The function <tt>workshop.plot()</tt> is essentially the <a href="http://code.google.com/p/flot/">flot</a>
plotting command.<br><br>

The <tt>numeric</tt> library provides functions that implement most of the usual Javascript
operators for vectors and matrices:
<pre>
> y = [10,1,2];
[10,1,2]
> numeric['+'](x,y)
[17,9,11]
> numeric['>'](x,y)
[false,true,true]
</pre>
 These operators can also be called with plain Javascript function names:
<pre>
> numeric.add(x,y)
[17,9,11]
</pre>

The function <tt>numeric.inv()</tt> can be used to compute the inverse of an invertible matrix:
<pre>
> A = [[1,2,3],[4,5,6],[7,1,9]]
[[1,2,3],
 [4,5,6],
 [7,1,9]]
> Ainv = numeric.inv(A);
[[-0.9286,0.3571,0.07143],
 [-0.1429,0.2857,-0.1429],
 [0.7381,-0.3095,0.07143]]
</pre>
The function <tt>numeric.prettyPrint()</tt> is used to print most of the examples in this documentation.
It formats objects, arrays and numbers so that they can be understood easily. All output is automatically
formatted using <tt>numeric.prettyPrint()</tt> when in the
<a href="http://www.numericjs.com/workshop.php">Workshop</a>. In order to present the information clearly and
succintly, the function <tt>numeric.prettyPrint()</tt> lays out matrices so that all the numbers align.
Furthermore, numbers are given approximately using the <tt>numeric.precision</tt> variable:
<pre>
> numeric.precision = 10; x = 3.141592653589793
3.141592654
> numeric.precision = 4; x
3.142
</pre>
The default precision is 4 digits. In addition to printing approximate numbers,
the function <tt>numeric.prettyPrint()</tt> will replace large arrays with the string <tt>...Large Array...</tt>:
<pre>
> numeric.identity(100)
...Large Array...
</pre> 
By default, this happens with the Array's length is more than 50. This can be controlled by setting the
variable <tt>numeric.largeArray</tt> to an appropriate value:
<pre>
> numeric.largeArray = 2; A = numeric.identity(4)
...Large Array...
> numeric.largeArray = 50; A
[[1,0,0,0],
 [0,1,0,0],
 [0,0,1,0],
 [0,0,0,1]]
</pre>
In particular, if you want to print all Arrays regardless of size, set <tt>numeric.largeArray = Infinity</tt>.
<br><br>

<h1>Math Object functions</h1>

The <tt>Math</tt> object functions have also been adapted to work on Arrays as follows:
<pre>
> numeric.exp([1,2]);
[2.718,7.389]
> numeric.exp([[1,2],[3,4]])
[[2.718, 7.389],
 [20.09, 54.6]]
> numeric.abs([-2,3])
[2,3]
> numeric.acos([0.1,0.2])
[1.471,1.369]
> numeric.asin([0.1,0.2])
[0.1002,0.2014]
> numeric.atan([1,2])
[0.7854,1.107]
> numeric.atan2([1,2],[3,4])
[0.3218,0.4636]
> numeric.ceil([-2.2,3.3])
[-2,4]
> numeric.floor([-2.2,3.3])
[-3,3]
> numeric.log([1,2])
[0,0.6931]
> numeric.round([-2.2,3.3])
[-2,3]
> numeric.sin([1,2])
[0.8415,0.9093]
> numeric.sqrt([1,2])
[1,1.414]
> numeric.tan([1,2])
[1.557,-2.185]
</pre>

<h1>Utility functions</h1>

The function <tt>numeric.dim()</tt> allows you to compute the dimensions of an Array.

<pre>
> numeric.dim([1,2])
[2]
> numeric.dim([[1,2,3],[4,5,6]])
[2,3]
> x = [[1,2,3],[4,5,6]]
[[1,2,3],
 [4,5,6]]
</pre>

You can perform a deep comparison of Arrays using <tt>numeric.same()</tt>:
<pre>
> numeric.same([1,2],[1,2])
true
> numeric.same([1,2],[1,2,3])
false
> numeric.same([1,2],[[1],[2]])
false
> numeric.same([[1,2],[3,4]],[[1,2],[3,4]])
true
> numeric.same([[1,2],[3,4]],[[1,2],[3,5]])
false
> numeric.same([[1,2],[2,4]],[[1,2],[3,4]])
false
</pre>

You can create a multidimensional Array from a given value using <tt>numeric.rep()</tt>
<pre>
> numeric.rep([3],5)
[5,5,5]
> numeric.rep([2,3],0)
[[0,0,0],
 [0,0,0]]
</pre>

You can loop over Arrays as you normally would. However, in order to quickly generate optimized
loops, the <tt>numeric</tt> library provides a few efficient loop-generation mechanisms. For example, the
<tt>numeric.mapreduce()</tt> function can be used to make a function that computes the sum of all the
entries of an Array.

<pre>
> sum = numeric.mapreduce('accum += xi','0'); sum([1,2,3])
6
> sum([[1,2,3],[4,5,6]])
21
</pre>

The functions <tt>numeric.any()</tt> and <tt>numeric.all()</tt> allow you to check whether any or all entries
of an Array are boolean true values.
<pre>
> numeric.any([false,true])
true
> numeric.any([[0,0,3.14],[0,false,0]])
true
> numeric.any([0,0,false])
false
> numeric.all([false,true])
false
> numeric.all([[1,4,3.14],["no",true,-1]])
true
> numeric.all([0,0,false])
false
</pre>

You can also create "pointwise" functions. This is how you create a vector sum function:

<pre>
> add = numeric.pointwise(['x[i]','y[i]'],'ret[i] = x[i]+y[i];'); add([1,2],[3,4])
[4,6]
</pre>

You can create a diagonal matrix using <tt>numeric.diag()</tt>
<pre>
> numeric.diag([1,2,3])
[[1,0,0],
 [0,2,0],
 [0,0,3]]
</pre>

The function <tt>numeric.identity()</tt> returns the identity matrix.
<pre>
> numeric.identity(3)
[[1,0,0],
 [0,1,0],
 [0,0,1]]
</pre>

Random Arrays can also be created:
<pre >
> numeric.random([2,3])
[[0.05303,0.1537,0.7280],
 [0.3839,0.08818,0.6316]]
</pre>

You can generate a vector of evenly spaced values:

<pre>
> numeric.linspace(1,5);
[1,2,3,4,5]
> numeric.linspace(1,3,5);
[1,1.5,2,2.5,3]
</pre>

<h1>Arithmetic operations</h1>

The standard arithmetic operations have been vectorized:
<pre>
> numeric.addVV([1,2],[3,4])
[4,6]
> numeric.addVS([1,2],3)
[4,5]
</pre>

There are also polymorphic functions:
<pre>
> numeric.add(1,[2,3])
[3,4]
> numeric.add([1,2,3],[4,5,6])
[5,7,9]
</pre>

The other arithmetic operations are available:
<pre>
> numeric.sub([1,2],[3,4])
[-2,-2]
> numeric.mul([1,2],[3,4])
[3,8]
> numeric.div([1,2],[3,4])
[0.3333,0.5]
</pre>

The in-place operators (such as +=) are also available:
<pre>
> v = [1,2,3,4]; numeric.addeq(v,3); v
[4,5,6,7]
> numeric.subeq([1,2,3],[5,3,1])
[-4,-1,2]
</pre>

Unary operators:
<pre>
> numeric.neg([1,-2,3])
[-1,2,-3]
> numeric.isFinite([10,NaN,Infinity])
[true,false,false]
> numeric.isNaN([10,NaN,Infinity])
[false,true,false]
</pre>


<!--
<pre>
> n = 41; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMsmall(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
> n = 42; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMsmall(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
> n = 43; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMsmall(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
> n = 44; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMbig(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
> n = 45; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMbig(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
> n = 46; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMbig(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
</pre>
-->

<h1>Linear algebra</h1>

Matrix products are implemented in the function the functions
<tt>numeric.dotVV()</tt>
<tt>numeric.dotVM()</tt>
<tt>numeric.dotMV()</tt>
<tt>numeric.dotMM()</tt>:
<pre>
> numeric.dotVV([1,2],[3,4])
11
> numeric.dotVM([1,2],[[3,4],[5,6]])
[13,16]
> numeric.dotMV([[1,2],[3,4]],[5,6])
[17,39]
> numeric.dotMMbig([[1,2],[3,4]],[[5,6],[7,8]])
[[19,22],
 [43,50]]
> numeric.dotMMsmall([[1,2],[3,4]],[[5,6],[7,8]])
[[19,22],
 [43,50]]
> numeric.dot([1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9])
285
</pre>

The function <tt>numeric.dot()</tt> is "polymorphic" and selects the appropriate Matrix product:

<pre>
> numeric.dot([1,2,3],[4,5,6])
32
> numeric.dot([[1,2,3],[4,5,6]],[7,8,9])
[50,122]
</pre>

The determinant:
<pre>
> numeric.det([[1,2],[3,4]]);
-2
> numeric.det([[6,8,4,2,8,5],[3,5,2,4,9,2],[7,6,8,3,4,5],[5,5,2,8,1,6],[3,2,2,4,2,2],[8,3,2,2,4,1]]);
-1404
</pre>

The matrix inverse:
<pre>
> numeric.inv([[1,2],[3,4]])
[[   -2,    1],
 [  1.5, -0.5]]
</pre>

The transpose:
<pre>
> numeric.transpose([[1,2,3],[4,5,6]])
[[1,4],
 [2,5],
 [3,6]]
> numeric.transpose([[1,2,3,4,5,6,7,8,9,10,11,12]])
[[ 1],
 [ 2],
 [ 3],
 [ 4],
 [ 5],
 [ 6],
 [ 7],
 [ 8],
 [ 9],
 [10],
 [11],
 [12]]
</pre>

You can compute the 2-norm of an Array, which is the square root of the sum of the squares of the entries.
<pre>
> numeric.norm2([1,2])
2.236
</pre>

Computing the tensor product of two vectors:
<pre>
> numeric.tensor([1,2],[3,4,5])
[[3,4,5],
 [6,8,10]]
</pre>

<h1>Data manipulation</h1>
There are also some data manipulation functions. You can parse dates:
<pre>
> numeric.parseDate(['1/13/2013','2001-5-9, 9:31']);
[1.358e12,9.894e11]
</pre>
Parse floating point quantities:
<pre>
> numeric.parseFloat(['12','0.1'])
[12,0.1]
</pre>
Parse CSV files:
<pre>
> numeric.parseCSV('a,b,c\n1,2.3,.3\n4e6,-5.3e-8,6.28e+4')
[[     "a",     "b",     "c"],
 [       1,     2.3,     0.3],
 [ 4.000e6, -5.3e-8,   62800]]
> numeric.toCSV([[1.23456789123,2],[3,4]])
"1.235,2
     3,4
"
</pre>
Note that <tt>numeric.toCSV()</tt> uses <tt>numeric.prettyPrint()</tt> to print numbers. To obtain more
digits, set <tt>numeric.precision</tt> to the desired number of digits of accuracy.

You can also fetch a URL (a thin wrapper around XMLHttpRequest):
<pre>
> numeric.getURL('tools/helloworld.txt').responseText
"Hello, world!"
</pre>

<h1>Complex linear algebra</h1>
You can also manipulate complex numbers:
<pre>
> z = new numeric.T(3,4);
{x: 3, y: 4}
> z.add(5)
{x: 8, y: 4}
> w = new numeric.T(2,8);
{x: 2, y: 8}
> z.add(w)
{x: 5, y: 12}
> z.mul(w)
{x: -26, y: 32}
> z.div(w)
{x:0.5588,y:-0.2353}
> z.sub(w)
{x:1, y:-4}
</pre>

Complex vectors and matrices can also be handled:
<pre>
> z = new numeric.T([1,2],[3,4]);
{x: [1,2], y: [3,4]}
> z.abs()
{x:[2,2.828],y:}
> z.conj()
{x:[1,2],y:[-3,-4]}
> z.norm2()
5.477
> z.exp()
{x:[-2.691,-4.83],y:[0.3836,-5.592]}
> z.cos()
{x:[-1.528,-2.459],y:[0.1658,-2.745]}
> z.sin()
{x:[0.2178,-2.847],y:[1.163,2.371]}
> z.log()
{x:[0.6931,1.04],y:[1.249,1.107]}
</pre>

Complex matrices:
<pre>
> A = new numeric.T([[1,2],[3,4]],[[0,1],[2,-1]]);
{x:[[1, 2],
    [3, 4]],
 y:[[0, 1],
    [2,-1]]}
> A.inv();
{x:[[0.125,0.125],
    [  0.25,    0]],
 y:[[   0.5,-0.25],
    [-0.375,0.125]]}
> A.inv().dot(A)
{x:[[1,         0],
    [0,         1]],
 y:[[0,-2.776e-17],
    [0,         0]]}
> A.get([1,1])
{x: 4, y: -1}
> A.transpose()
{ x: [[1, 3],
      [2, 4]],
  y: [[0, 2],
      [1,-1]] }
> A.transjugate()
{ x: [[ 1, 3],
      [ 2, 4]],
  y: [[ 0,-2],
      [-1, 1]] }
> numeric.T.rep([2,2],new numeric.T(2,3));
{ x: [[2,2],
      [2,2]],
  y: [[3,3],
      [3,3]] }
</pre>

<h1>Eigenvalues</h1>
Eigenvalues:
<pre>
> A = [[1,2,5],[3,5,0],[7,-3,5]];
[[ 1, 2, 5],
 [ 3, 5, 0],
 [ 7,-3, 5]]
> B = numeric.eig(A);
{lambda:{x:[-4.068,8.742,6.326],y:},
 E: {x: [[ 0.7281,-0.5634, 0.4034 ],
         [-0.2409,-0.4516, 0.9127 ],
         [-0.6417,-0.6918, 0.06462]],
    y:}}
> C = B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv());
{x:[[    1,     2,      5   ],
    [    3,     5,-1.943e-15],
    [    7,    -3,      5   ]],
y:}
> C.sub(A).norm2()<1e-13
true
</pre>
Note that eigenvalues and eigenvectors are returned as complex numbers (type <tt>numeric.T</tt>). This is because
eigenvalues are often complex even when the matrix is real.<br><br>

<h1>Singular value decomposition (Shati Rao)</h1>

Shanti Rao kindly emailed me an implementation of the Golub and Reisch algorithm:

<pre>
> A = [[22,10,2,3,7],[14,7,10,0,8],[-1,13,-1,-11,3],[-3,-2,13,-2,4],[9,8,1,-2,4],[9,1,-7,5,-1],[2,-6,6,5,1],[4,5,0,-2,2]]
[[ 22, 10,  2,  3,  7],
 [ 14,  7, 10,  0,  8],
 [ -1, 13, -1,-11,  3],
 [ -3, -2, 13, -2,  4],
 [  9,  8,  1, -2,  4],
 [  9,  1, -7,  5, -1],
 [  2, -6,  6,  5,  1],
 [  4,  5,  0, -2,  2]]
> numeric.svd(A)
{U: 
[[    -0.7071,    -0.1581,     0.1768,     0.2494,     0.4625],
 [    -0.5303,    -0.1581,    -0.3536,     0.1556,    -0.4984],
 [    -0.1768,     0.7906,    -0.1768,    -0.1546,     0.3967],
 [ -1.506e-17,    -0.1581,    -0.7071,    -0.3277,        0.1],
 [    -0.3536,     0.1581,  1.954e-15,   -0.07265,    -0.2084],
 [    -0.1768,    -0.1581,     0.5303,    -0.5726,   -0.05555],
 [ -7.109e-18,    -0.4743,    -0.1768,    -0.3142,     0.4959],
 [    -0.1768,     0.1581,  1.915e-15,     -0.592,    -0.2791]],
S: 
[      35.33,         20,       19.6,          0,          0],
V: 
[[    -0.8006,    -0.3162,     0.2887,    -0.4191,          0],
 [    -0.4804,     0.6325,  7.768e-15,     0.4405,     0.4185],
 [    -0.1601,    -0.3162,     -0.866,     -0.052,     0.3488],
 [  4.684e-17,    -0.6325,     0.2887,     0.6761,     0.2442],
 [    -0.3203,  3.594e-15,    -0.2887,      0.413,    -0.8022]]}
</pre>

<!--
  Some further tests.
<pre>
> n = 31; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda).dot(B.E.inv())).sub(A).norm2()<1e-12
true
> n = 32; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 33; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 34; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 41; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 42; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 43; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 44; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
</pre>
-->

<h1>Sparse linear algebra</h1>
Sparse linear algebra is available in the sparse module:
<pre>
> sparse.identity(3)
[[1],
 [ ,1],
 [ , ,1]]
> sparse.transpose([[1],[2,3],[4,5,6]])
[[1,2,4],
 [ ,3,5],
 [ , ,6]]
> A = [[2,-1],[-1,2,-1],[,-1,2]]; lup = sparse.LUP(A)
{L: [[   1],
     [-0.5,      1],
     [    ,-0.6667,     1]],
 U: [[   2,     -1],
     [    ,    1.5,    -1],
     [    ,       , 1.333]],
 P: [0,1,2],
 Pinv: [0,1,2]}
> sparse.dot(lup.L,lup.U)
[[   2,  -1],
 [  -1,   2,  -1],
 [    ,  -1,   2]]
> x = [3,1,7]; b = sparse.dot(A,x);
[5,-8,13]
> sparse.LUPsolve(lup,b)
[3,1,7]
</pre>

<!--
Some more tests.
<pre>
> sparse.dot([1,2,3],[,4,5])
23
> sparse.dot([1, ,3],[[4,5,],[,6,7],[1,,8]])
[7,5,24]
> sparse.dot([[3,1],[4,5,9],[,3,2]],[7,3])
[24,43,9]
</pre>
-->

The <tt>sparse.scatter()</tt> and <tt>sparse.gather()</tt> functions can be used to convert between
sparse matrices and the coordinate encoding:
<pre>
> A = sparse.scatter([[0,0,1,1,1,2,2],[0,1,0,1,2,1,2],[1,2,3,4,5,6,7]])
[[1,2],
 [3,4,5],
 [ ,6,7]]
> sparse.gather(A)
[[0,0,1,1,1,2,2],
 [0,1,0,1,2,1,2],
 [1,2,3,4,5,6,7]]
</pre>

<h1>Coordinate matrices</h1>

Sparse matrices can be very slow in certain browsers. The <tt>coord</tt> module provides functions that
work with matrices in the coordinate encoding using band strategies that often execute faster if
your matrices happen to be banded.<br><br>

LU decomposition:
<pre>
> lu = coord.LU([[0,0,1,1,1,2,2],[0,1,0,1,2,1,2],[2,-1,-1,2,-1,-1,2]])
{U:[[    0,    0,    1,      1,  2   ],
    [    0,    1,    1,      2,  2   ],
    [    2,   -1,  1.5,     -1, 1.333]],
 L:[[    0,    1,    1,      2,  2   ],
    [    0,    0,    1,      1,  2   ],
    [    1, -0.5,    1,-0.6667,  1   ]]}
> coord.LUsolve(lu,[5,-8,13])
[3,1,7]
</pre>
Note that <tt>coord.LU()</tt> does not have any pivoting.

<h1>Solving PDEs</h1>

The functions <tt>coord.grid()</tt> and <tt>coord.delsq()</tt> can be used to obtain a
numerical Laplacian for a domain.

<pre>
> g = coord.grid(5)
[[-1,-1,-1,-1,-1],
 [-1, 0, 1, 2,-1],
 [-1, 3, 4, 5,-1],
 [-1, 6, 7, 8,-1],
 [-1,-1,-1,-1,-1]]
> coordL = coord.delsq(g)
[[ 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8],
 [ 1, 3, 0, 0, 2, 4, 1, 1, 5, 2, 0, 4, 6, 3, 1, 3, 5, 7, 4, 2, 4, 8, 5, 3, 7, 6, 4, 6, 8, 7, 5, 7, 8],
 [-1,-1, 4,-1,-1,-1, 4,-1,-1, 4,-1,-1,-1, 4,-1,-1,-1,-1, 4,-1,-1,-1, 4,-1,-1, 4,-1,-1,-1, 4,-1,-1, 4]]
> L = sparse.scatter(coordL); // Just to see what it looks like
[[          4,         -1,           ,         -1],
 [         -1,          4,         -1,           ,         -1],
 [           ,         -1,          4,           ,           ,         -1],
 [         -1,           ,           ,          4,         -1,           ,         -1],
 [           ,         -1,           ,         -1,          4,         -1,           ,         -1],
 [           ,           ,         -1,           ,         -1,          4,           ,           ,         -1],
 [           ,           ,           ,         -1,           ,           ,          4,         -1],
 [           ,           ,           ,           ,         -1,           ,         -1,          4,         -1],
 [           ,           ,           ,           ,           ,         -1,           ,         -1,          4]]
> lu = coord.LU(coordL); x = coord.LUsolve(lu,[1,1,1,1,1,1,1,1,1]);
[0.6875,0.875,0.6875,0.875,1.125,0.875,0.6875,0.875,0.6875]
> coord.dotMV(coordL,x)
[1,1,1,1,1,1,1,1,1]
> G = numeric.rep([5,5],0); for(i=0;i<5;i++) for(j=0;j<5;j++) if(g[i][j]>=0) G[i][j] = x[g[i][j]]; G
[[ 0     , 0     , 0     , 0     , 0     ],
 [ 0     , 0.6875, 0.875 , 0.6875, 0     ],
 [ 0     , 0.875 , 1.125 , 0.875 , 0     ],
 [ 0     , 0.6875, 0.875 , 0.6875, 0     ],
 [ 0     , 0     , 0     , 0     , 0     ]]
> workshop.html('&lt;img src="'+numeric.imageURL(numeric.mul([G,G,G],200))+'" width=100&gt;');
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAAAcElEQVQIHQARAO7/AAAAAAAAAAAAAAAAAAAAAAAAEADv/wAAAIqKiq+vr4mJiQAAAAAAEADv/wAAAK+vr+Hh4a+vrwAAAAAAEADv/wAAAIqKiq+vr4qKigAAAAABEADv/wAAAAAAAAAAAAAAAAAAAACRjRFNqL3leAAAAABJRU5ErkJggg==" width=100>
</pre>

You can also work on an L-shaped or arbitrary-shape domain:
<pre>
> coord.grid(6,'L')
[[-1,-1,-1,-1,-1,-1],
 [-1, 0, 1,-1,-1,-1],
 [-1, 2, 3,-1,-1,-1],
 [-1, 4, 5, 6, 7,-1],
 [-1, 8, 9,10,11,-1],
 [-1,-1,-1,-1,-1,-1]]
> coord.grid(5,function(i,j) { return i!==2 || j!==2; })
[[-1,-1,-1,-1,-1],
 [-1, 0, 1, 2,-1],
 [-1, 3,-1, 4,-1],
 [-1, 5, 6, 7,-1],
 [-1,-1,-1,-1,-1]]
</pre>

<h1>Quadratic Programming (Alberto Santini)</h1>

The Quadratic Programming function <tt>numeric.solveQP()</tt> is based on <a href="https://github.com/albertosantini/node-quadprog">Alberto Santini's
quadprog</a>, which is itself a port of the corresponding
R routines.

<pre>
> numeric.solveQP([[1,0,0],[0,1,0],[0,0,1]],[0,5,0],[[-4,2,0],[-3,1,-2],[0,0,1]],[-8,2,0]);
{ solution:              [0.4762,1.048,2.095],
  value:                 [-2.381],
  unconstrained_solution:[     0,    5,    0],
  iterations:            [     3,    0],
  iact:                  [     3,    2,    0],
  message:               "" }
</pre>

<!--
<pre>
> D = numeric.identity(8); d = numeric.rep([8],0); A = [[1, 1, -1, 0,  0, 0,  0, 0,  0, 0],[-1, 1,  0, 1,  0, 0,  0, 0,  0, 0],[1, 1,  0, 0, -1, 0,  0, 0,  0, 0],[-1, 1,  0, 0,  0, 1,  0, 0,  0, 0],[1, 1,  0, 0,  0, 0, -1, 0,  0, 0],[-1, 1,  0, 0,  0, 0,  0, 1,  0, 0],[1, 1,  0, 0,  0, 0,  0, 0, -1, 0],[-1, 1,  0, 0,  0, 0,  0, 0,  0, 1]]; b = [1,  1, -1,  0, -1,  0, -1,  0, -1,  0]; numeric.solveQP(D,d,A,b,undefined,2)
{ solution:              [0.25,0,0.25,0,0.25,0,0.25,0],
  value:                 [0.125],
  unconstrained_solution:[0,0,0,0,0,0,0,0],
  iterations:            [3,0],
  iact:                  [1,2,0,0,0,0,0,0,0,0],
  message:               ""}
> numeric.imageURL(numeric.rep([3],[[1,2],[3,4]]));
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAIAAAD91JpzAAAAH0lEQVQIHQAIAPf/AAEBAQICAgABBwD4/wMDAwQEBAAAogAfhs2H3QAAAABJRU5ErkJggg=="
</pre>
-->

<h1>Seedrandom (David Bau)</h1>

The object <tt>numeric.seedrandom</tt> is based on 
<a href="http://davidbau.com/archives/2010/01/30/random_seeds_coded_hints_and_quintillions.html">David Bau's <tt>seedrandom.js</tt></a>.
This small library can be used to create better pseudorandom numbers than <tt>Math.random()</tt> which can
furthermore be "seeded".
<pre>
> numeric.seedrandom.seedrandom(3); numeric.seedrandom.random()
0.7569
> numeric.seedrandom.random()
0.6139
> numeric.seedrandom.seedrandom(3); numeric.seedrandom.random()
0.7569
</pre>
For performance reasons, <tt>numeric.random()</tt> uses the default <tt>Math.random()</tt>. If you want to use
the seedrandom version, just do <tt>Math.random = numeric.seedrandom.random</tt>. Note that this may slightly
decrease the performance of all <tt>Math</tt> operations.

<br><br><br>

