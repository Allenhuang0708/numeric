<head>
<link rel="SHORTCUT ICON" href="favicon.ico">
<link rel="stylesheet" type="text/css" href="resources/style.css">
<title>Numeric Javascript: Benchmarks</title>
</head>
<body>
<a href="https://github.com/sloisel/numeric"><img style="position: absolute; top: 0; right: 0; border: 0;" src="resources/forkme.png" alt="Fork me on GitHub"></a>
<table class="nav"><tr class="nav">
<td class="nav" style="width:150px;"><img src="resources/paperplane-small.png">
<td class="navmain">
<b>Numeric Javascript: Documentation</b>
<ul class="nav">
	<li class="nav"><a id = "linkhome" class="nav" href="index.html">HOME</a></li>
	<li class="nav"><a id = "linkworkshop" class="nav" href="workshop.php">WORKSHOP</a></li>
	<li class="nav"><a id = "linkbenchmarks" class="nav" href="benchmark.html">BENCHMARKS</a></li>
	<li class="nav"><a id = "linkdoc" class="nav" href="documentation.html">DOCUMENTATION</a></li>
</ul>
<ul class="nav">
	<li class="sep">DOWNLOADS:</li>
	<li class="nav"><a id = "linklib" class="dl" href="lib/numeric.js">numeric.js</a></li>
	<li class="nav"><a id = "linklibmin" class="dl" href="lib/numeric-min.js">numeric-min.js</a></li>
</ul>
</table>
<!--
This allows regression tests to run predictably:
<pre>
> numeric.seedrandom.seedrandom('1'); Math.random = numeric.seedrandom.random; Math.random();
0.2694
</pre>
-->
<a href="http://www.numericjs.com/">Numeric Javascript</a> is
library that provides many useful functions for numerical
calculations, particularly for linear algebra (vectors and matrices). 
You can create vectors and matrices and multiply them:
<pre>
> A = [[1,2,3],[4,5,6]];
[[1,2,3],
 [4,5,6]]
> x = [7,8,9]
[7,8,9]
> numeric.dot(A,x);
[50,122]
</pre>
The example shown above can be executed in the
<a href="http://www.numericjs.com/workshop.php">Javascript Workshop</a> or at any
Javascript prompt. The Workshop provides plotting capabilities:<br>
<img src="resources/workshop.png"><br>
The function <tt>workshop.plot()</tt> is essentially the <a href="http://code.google.com/p/flot/">flot</a>
plotting command.<br><br>
 
The <tt>numeric</tt> library provides functions that implement most of the usual Javascript
operators for vectors and matrices:
<pre>
> y = [10,1,2];
[10,1,2]
> numeric['+'](x,y)
[17,9,11]
> numeric['>'](x,y)
[false,true,true]
</pre>
 These operators can also be called with plain Javascript function names:
<pre>
> numeric.add(x,y)
[17,9,11]
</pre>

The function <tt>numeric.inv()</tt> can be used to compute the inverse of an invertible matrix:
<pre>
> A = [[1,2,3],[4,5,6],[7,1,9]]
[[1,2,3],
 [4,5,6],
 [7,1,9]]
> Ainv = numeric.inv(A);
[[-0.9286,0.3571,0.07143],
 [-0.1429,0.2857,-0.1429],
 [0.7381,-0.3095,0.07143]]
</pre>

The <tt>Math</tt> object functions have also been adapted to work on Arrays as follows:
<pre>
> numeric.exp([1,2]);
[2.718,7.389]
> numeric.exp([[1,2],[3,4]])
[[2.718,7.389],[20.09,54.60]]
> numeric.abs([-2,3])
[2,3]
> numeric.acos([0.1,0.2])
[1.471,1.369]
> numeric.asin([0.1,0.2])
[0.1002,0.2014]
> numeric.atan([1,2])
[0.7854,1.107]
> numeric.atan2([1,2],[3,4])
[0.3218,0.4636]
> numeric.ceil([-2.2,3.3])
[-2,4]
> numeric.floor([-2.2,3.3])
[-3,3]
> numeric.log([1,2])
[0,0.6931]
> numeric.round([-2.2,3.3])
[-2,3]
> numeric.sin([1,2])
[0.8415,0.9093]
> numeric.sqrt([1,2])
[1,1.414]
> numeric.tan([1,2])
[1.557,-2.185]
</pre>

The function <tt>numeric.dim()</tt> allows you to compute the dimensions of an Array.

<pre>
> numeric.dim([1,2])
[2]
> numeric.dim([[1,2,3],[4,5,6]])
[2,3]
> x = [[1,2,3],[4,5,6]]
[[1,2,3],[4,5,6]]
</pre>

You can perform a deep comparison of Arrays using <tt>numeric.same()</tt>:
<pre>
> numeric.same([1,2],[1,2])
true
> numeric.same([1,2],[1,2,3])
false
> numeric.same([1,2],[[1],[2]])
false
> numeric.same([[1,2],[3,4]],[[1,2],[3,4]])
true
> numeric.same([[1,2],[3,4]],[[1,2],[3,5]])
false
> numeric.same([[1,2],[2,4]],[[1,2],[3,4]])
false
</pre>

You can loop over Arrays as you normally would. However, in order to quickly generate optimized
loops, the <tt>numeric</tt> library provides a few efficient loop-generation mechanisms. For example, the
<tt>numeric.mapreduce()</tt> function can be used to make a function that computes the sum of all the
entries of an Array.

<pre>
> sum = numeric.mapreduce('accum += xi','0'); sum([1,2,3])
6
> sum([[1,2,3],[4,5,6]])
21
</pre>

The functions <tt>numeric.any()</tt> and <tt>numeric.all()</tt> allow you to check whether any or all entries
of an Array are boolean true values.
<pre>
> numeric.any([false,true])
true
> numeric.any([[0,0,3.14],[0,false,0]])
true
> numeric.any([0,0,false])
false
> numeric.all([false,true])
false
> numeric.all([[1,4,3.14],["no",true,-1]])
true
> numeric.all([0,0,false])
false
</pre>

You can also create "pointwise" functions. This is how you create a vector sum function:

<pre>
> add = numeric.pointwise(['x[i]','y[i]'],'ret[i] = x[i]+y[i];'); add([1,2],[3,4])
[4,6]
</pre>

The standard arithmetic operations have been vectorized:
<pre>
> numeric.addVV([1,2],[3,4])
[4,6]
> numeric.addVS([1,2],3)
[4,5]
</pre>

There are also polymorphic functions:
<pre>
> numeric.add(1,[2,3])
[3,4]
> numeric.add([1,2,3],[4,5,6])
[5,7,9]
</pre>

The other arithmetic operations are available:
<pre>
> numeric.sub([1,2],[3,4])
[-2,-2]
> numeric.mul([1,2],[3,4])
[3,8]
> numeric.div([1,2],[3,4])
[0.3333,0.5]
</pre>

The in-place operators (such as +=) are also available:
<pre>
> v = [1,2,3,4]; numeric.addeq(v,3); v
[4,5,6,7]
> numeric.subeq([1,2,3],[5,3,1])
[-4,-1,2]
</pre>

You can create a multidimensional Array from a given value using <tt>numeric.rep()</tt>
<pre>
> numeric.rep([3],5)
[5,5,5]
> numeric.rep([2,3],0)
[[0,0,0],
 [0,0,0]]
</pre>

Matrix products are implemented in the function the functions 
<tt>numeric.dotVV()</tt>
<tt>numeric.dotVM()</tt>
<tt>numeric.dotMV()</tt>
<tt>numeric.dotMM()</tt>:
<pre>
> numeric.dotVV([1,2],[3,4])
11
> numeric.dotVM([1,2],[[3,4],[5,6]])
[13,16]
> numeric.dotMV([[1,2],[3,4]],[5,6])
[17,39]
> numeric.dotMMbig([[1,2],[3,4]],[[5,6],[7,8]])
[[19,22],
 [43,50]]
> numeric.dotMMsmall([[1,2],[3,4]],[[5,6],[7,8]])
[[19,22],
 [43,50]]
> numeric.dot([1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9])
285
</pre>

Unary operators:
<pre>
> numeric.neg([1,-2,3])
[-1,2,-3]
> numeric.isFinite([10,NaN,Infinity])
[true,false,false]
> numeric.isNaN([10,NaN,Infinity])
[false,true,false]
</pre>

The function <tt>numeric.dot()</tt> is "polymorphic" and selects the appropriate Matrix product:

<pre>
> numeric.dot([1,2,3],[4,5,6])
32
> numeric.dot([[1,2,3],[4,5,6]],[7,8,9])
[50,122]
</pre>

<!--
<pre>
> n = 41; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMsmall(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
> n = 42; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMsmall(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
> n = 43; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMsmall(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
> n = 44; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMbig(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
> n = 45; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMbig(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
> n = 46; A = numeric.random([n,n]); numeric.norm2(numeric.sub(numeric.dotMMbig(numeric.inv(A),A),numeric.identity(n)))<1e-12
true
</pre> 
-->

You can create a diagonal matrix using <tt>numeric.diag()</tt>
<pre>
> numeric.diag([1,2,3])
[[1,0,0],
 [0,2,0],
 [0,0,3]]
</pre>

The function <tt>numeric.identity()</tt> returns the identity matrix.
<pre>
> numeric.identity(3)
[[1,0,0],
 [0,1,0],
 [0,0,1]]
</pre>

Random Arrays can also be created:
<pre >
> numeric.random([2,3])
[[0.05303,0.1537,0.7280],
 [0.3839,0.08818,0.6316]]
</pre>

You can generate a vector of evenly spaced values:

<pre>
> numeric.linspace(1,5);
[1,2,3,4,5]
> numeric.linspace(1,3,5);
[1,1.5,2,2.5,3]
</pre>

The determinant:
<pre>
> numeric.det([[1,2],[3,4]]);
-2
> numeric.det([[6,8,4,2,8,5],[3,5,2,4,9,2],[7,6,8,3,4,5],[5,5,2,8,1,6],[3,2,2,4,2,2],[8,3,2,2,4,1]]);
-1404
</pre>

The transpose:
<pre>
> numeric.transpose([[1,2,3],[4,5,6]])
[[1,4],
 [2,5],
 [3,6]]
> numeric.transpose([[1,2,3,4,5,6,7,8,9,10,11,12]])
[[ 1],
 [ 2],
 [ 3],
 [ 4],
 [ 5],
 [ 6],
 [ 7],
 [ 8],
 [ 9],
 [10],
 [11],
 [12]]
</pre>

You can compute the 2-norm of an Array, which is the square root of the sum of the squares of the entries.
<pre>
> numeric.norm2([1,2])
2.236
</pre>

Computing the tensor product of two vectors:
<pre>
> numeric.tensor([1,2],[3,4,5])
[[3,4,5],
 [6,8,10]]
</pre>

There are also some data manipulation functions. You can parse dates:
<pre>
> numeric.parseDate(['1/13/2013','2001-5-9, 9:31']);
[1.358e12,9.894e11]
</pre>
Parse floating point quantities:
<pre>
> numeric.parseFloat(['12','0.1'])
[12,0.1]
</pre>
Parse CSV files:
<pre>
> numeric.parseCSV('a,b,c\n1,2.3,.3\n4e6,-5.3e-8,6.28e+4')
[[     "a",     "b",     "c"],
 [       1,     2.3,     0.3],
 [ 4.000e6, -5.3e-8,   62800]]
</pre>

You can also fetch a URL:
<pre>
> numeric.getURL('tools/helloworld.txt').responseText
"Hello, world!"
</pre>


You can also manipulate complex numbers:
<pre>
> z = new numeric.T(3,4);
{x: 3, y: 4}
> z.add(5)
{x: 8, y: 4}
> w = new numeric.T(2,8);
{x: 2, y: 8}
> z.add(w)
{x: 5, y: 12}
> z.mul(w)
{x: -26, y: 32}
> z.div(w)
{x:0.5588,y:-0.2353}
> z.sub(w)
{x:1, y:-4}
</pre>

Complex vectors and matrices can also be handled:
<pre>
> z = new numeric.T([1,2],[3,4]);
{x: [1,2], y: [3,4]}
> z.abs()
{x:[2,2.828],y:}
> z.conj()
{x:[1,2],y:[-3,-4]}
> z.norm2()
5.477
> z.exp()
{x:[-2.691,-4.830],y:[0.3836,-5.592]}
> z.cos()
{x:[-1.528,-2.459],y:[0.1658,-2.745]}
> z.sin()
{x:[0.2178,-2.847],y:[1.163,2.371]}
> z.log()
{x:[0.6931,1.040],y:[1.249,1.107]}
</pre>

Complex matrices:
<pre>
> A = new numeric.T([[1,2],[3,4]],[[0,1],[2,-1]]);
{x:[[1, 2],
	[3, 4]],
 y:[[0, 1],
    [2,-1]]}
> A.inv();
{x:[[0.1250,0.125],
	[  0.25,    0]],
 y:[[   0.5,-0.25],
    [-0.375,0.125]]}
> A.inv().dot(A)
{x:[[1,         0],
	[0,         1]],
 y:[[0,-2.776e-17],
    [0,         0]]}
> A.get([1,1])
{x: 4, y: -1}
> A.transpose()
{ x: [[1, 3],
	  [2, 4]], 
  y: [[0, 2],
      [1,-1]] }
> A.transjugate()
{ x: [[ 1, 3],
	  [ 2, 4]], 
  y: [[ 0,-2],
      [-1, 1]] }
> numeric.T.rep([2,2],new numeric.T(2,3));
{ x: [[2,2],
	  [2,2]],
  y: [[3,3],
      [3,3]] }
</pre>

Eigenvalues:
<pre>
> A = [[1,2,5],[3,5,0],[7,-3,5]];
[[ 1, 2, 5],
 [ 3, 5, 0],
 [ 7,-3, 5]]
> B = numeric.eig(A);
{lambda:{x:[8.742,-4.068,6.326],y:},
 E: {x: [[-0.5634,-0.7281,-0.4034 ],
 	     [-0.4516, 0.2409,-0.9127 ],
 	     [-0.6918, 0.6417,-0.06462]],
 	 y:}}
> C = B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv());
{x:[[1.000,2     ,5        ],
	[3    ,5     ,8.882e-16],
	[7    ,-3.000,5.000    ]],
y:}
> C.sub(A).norm2()<1e-14
true
</pre>
Note that eigenvalues and eigenvectors are returned as complex numbers (type <tt>numeric.T</tt>). This is because
eigenvalues are often complex even when the matrix is real. For example:
<pre>
> B = numeric.eig([[1,2,3,4],[-1,1,-1,1],[3,3,9,13],[1,14,1,0]])
{lambda:{x: [-5.312 ,-0.09390,  8.203  ,  8.203  ],
         y: [0      ,0       , -2.213  ,  2.213  ]},
      E:{x:[[ 0.1120,-0.7849 ,  0.2936 , -0.01754],
      	    [ 0.2330, 0.01638, -0.1545 ,  0.08076],
      	    [ 0.6089, 0.5767 ,  0.9220 , -0.07533],
      	    [-0.7499,-0.2261 , -0.07583,  0.1470 ]],
      	 y:[[      0,       0,  0.01754, -0.2936 ],
      	    [      0,       0, -0.08076,  0.1545 ],
      	    [      0,       0,  0.07533, -0.9220 ],
      	    [      0,       0,  -0.1470,  0.07583]]}}
> B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv())
{x:[[     1.000,     2.000,     3.000,     4.000],
	[    -1    ,     1.000,    -1    ,     1.000],
	[     3.000,     3.000,     9.000,    13.00 ],
	[     1.000,    14.00 ,     1.000, 5.995e-15]],
 y:[[-1.110e-16,-1.776e-15,-4.441e-16, 8.882e-16],
    [ 1.388e-16,-2.665e-15,-2.220e-16,-8.882e-16],
    [-4.441e-16,-7.105e-15,-1.776e-15,-5.329e-15],
    [ 1.665e-16, 6.217e-15, 1.138e-15, 2.887e-15]]}
</pre>
This matrix has two real eigenvalues (-5.312 and -0.09390) and a pair of complex eigenvalues 0.8203 +/- 2.213i.

<!--
	Some further tests.
<pre>
> n = 31; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda).dot(B.E.inv())).sub(A).norm2()<1e-12
true
> n = 32; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 33; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 34; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 41; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 42; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 43; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
> n = 44; A = numeric.random([n,n]); B = numeric.eig(A); B.E.dot(numeric.T.diag(B.lambda)).dot(B.E.inv()).sub(A).norm2()<1e-12
true
</pre>
-->

<br><br><br>
